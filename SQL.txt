Запрос на выгрузку данных начинают со слова SELECT

//SELECT 'Здравствуйте, я ваш первый запрос!';

//Чтобы выгрузить данные из таблицы, нужно указать, откуда именно их брать. Для этого дополним запрос словом FROM
Запрос для выгрузки данных - FROM
Символ * в SQL означает «всё»
SELECT *
FROM buyer;

//Оператор COUNT() подсчитывает число записей. А поскольку в операторе мы указали *, запрос можно перевести как «подсчитать всё»
SELECT COUNT(*)
FROM buyer; 

//Оператор LIMIT
Такой запрос отобразит десять записей из перечисленных полей: 
SELECT поле_1,
       поле_2,
       поле_3
             ...
FROM таблица
LIMIT 10;

//Оператор OFFSET
Если нужно указать, с какой записи начинать выборку, к оператору LIMIT добавляют оператор OFFSET. Он позволяет пропустить определённое число записей.
SELECT поле_1,
       поле_2,
       поле_3
             ...
FROM таблица
LIMIT 10 OFFSET 5; 

Такой запрос выведет записи с 6 по 15

OFFSET — самостоятельный оператор. Чтобы отобразить записи всей таблицы, начиная с определённой, указывают только оператор OFFSET без оператора LIMIT. Например, если нужно отобразить всю таблицу, начиная с шестой записи, запрос будет выглядеть так:
SELECT поле_1,
       поле_2,
       поле_3
             ...
FROM таблица
OFFSET 5; 

//Переименование поля с помощью AS
Теперь каждому полю в запросе можно назначить псевдоним, или алиас. Для этого после нужного поля указывают оператор AS (англ. «как») и пишут псевдоним.
SELECT first_name,
       age AS age_client,
       connection_area AS area
FROM buyer; 

//Оператор WHERE

SELECT поле_1, -- поля для выгрузки
       поле_2 
             ...
FROM таблица -- таблица, из которой выгружают данные
WHERE поле > 4; -- условие для среза данных
= — равно;
!= — не равно;
> — больше;
< — меньше;
>= — больше или равно;
<= — меньше или равно.
Сравнение с числом записывают просто: WHERE поле < 5. Но если значение сравнивают с символьным типом, набор символов нужно взять в одинарные кавычки: WHERE поле = 'Иванов'. Это правило также касается даты и времени: WHERE поле = '2013-07-01'.
В PostgreSQL в операторе WHERE нельзя использовать псевдонимы. Потому что «под капотом» во время компиляции WHERE выполняется раньше, чем SELECT, когда псевдонимы ещё не назначены.

//Операторы AND и OR и NOT и IN
WHERE connection_area = 'Роботический лабиринт'
  AND age > 30;

WHERE age > 30 
  OR age < 20;

WHERE NOT connection_area = 'Роботический лабиринт'

WHERE NOT age = 30
  AND NOT age = 20;

WHERE age > 25 
  AND first_name IN ('Виктор', 'Любовь', 'Борис', 'Станислав', 'Алина', 'Евгения', 'Ольга'); 

WHERE age > 25 
  AND first_name NOT IN ('Виктор', 'Любовь', 'Борис', 'Станислав', 'Алина', 'Евгения', 'Ольга'); 

WHERE (age > 30
  AND connection_area = 'Роботический лабиринт')
  OR (connection_area = 'Интерактивный музей робототехники'
  AND age < 20);

Первые условия выполняются в скобках

//Фильтрация по дате
WHERE date >= '2022-02-27' AND date <= '2022-03-14'; 
Функция DATE_TRUNC
Дата и время часто хранятся в таком виде: '2009-11-19 11:03:05'. Но сравнивать даты в таком формате неудобно, если нужен, например, только год. 
В таких случаях в PostegreSQL используют функцию DATE_TRUNC, которая «усекает» дату и время до необходимого значения. Синтаксис функции такой: DATE_TRUNC('отрезок времени', поле). 
Отрезок времени может быть разным, главное — не забыть одинарные кавычки:
'microseconds' — микросекунды;
'milliseconds' — миллисекунды;
'second' — секунда;
'minute' — минута;
'hour' — час;
'day' — день;
'week' — неделя;
'month' — месяц;
'quarter' — квартал;
'year' — год;
'decade' — десятилетие;
'century' — век.

SELECT date,
       DATE_TRUNC('month', date)
FROM hotdog
LIMIT 5; 

Отфильтруем заказы хот-догов в феврале.
SELECT order_id,
       bracelet_id,
       date,
       name_hotdog,
       ingredients
FROM hotdog
WHERE DATE_TRUNC('month', date) = '2022-02-01'
LIMIT 5; 

//Функция EXTRACT
Чтобы получить только конкретную часть даты — год, месяц или минуту, — используют функцию EXTRACT. Её синтаксис: EXTRACT(отрезок времени FROM поле). 
Одинарные кавычки для значений внутри EXTRACT не нужны. Отрезок времени можно представить следующими значениями:
CENTURY — век;
YEAR — год;
QUARTER — квартал;
MONTH — месяц;
WEEK — неделя в году;
DAY — день;
DOY (от англ. day of the year) — день года, выраженный числом от 1 до 365 или 366, если год високосный;
DOW (от англ. day of the week) — день недели, выраженный числом от 0 до 6, где понедельник — 1, воскресенье — 0.
ISODOW (от англ. day of the week и ISO 8601) — день недели, выраженный числом от 1 до 7, где понедельник — 1, воскресенье — 7;
HOUR — час;
MINUTE — минута;
SECOND — секунда;
MILLISECOND — миллисекунда.
Выделим номер недели из поля с датой так же, как ранее мы делали с месяцем. На этот раз применим EXTRACT:
SELECT date,
       EXTRACT(WEEK FROM date)
FROM hotdog
LIMIT 5; 

SELECT order_id,
       bracelet_id,
       date,
       name_hotdog,
       ingredients
FROM hotdog
WHERE EXTRACT(WEEK FROM date) = 7
LIMIT 5; 


//Агрегирующие функции
Агрегирующие функции позволяют проводить расчёты над группами данных и отображают результат в виде одной строки.
Основные агрегирующие функции в SQL:
SUM(поле) возвращает сумму значений в поле;
AVG(поле) находит среднее арифметическое для значений в поле;
MIN(поле) возвращает минимальное значение в поле;
МАХ(поле) возвращает максимальное значение в поле;
COUNT(поле) выводит количество записей в поле.
Применим эти функции к полю age таблицы buyer и посмотрим на результат:
SELECT SUM(age),
       AVG(age),
       MIN(age),
       MAX(age),
       COUNT(age)
FROM buyer; 

//Функция DISTINCT
позволяет находить и рассчитывать показатели только по уникальным значениям
SELECT DISTINCT(percent_of_discount)
FROM buyer
сколько всего пользователей в таблице hotdog и сколько — уникальных:
SELECT COUNT(DISTINCT(bracelet_id)),
       COUNT(bracelet_id)
FROM hotdog; 

SELECT AVG(age)
FROM buyer
WHERE gender = 'Мужской'

//Оператор GROUP BY
Для группировки применяют оператор GROUP BY: его записывают после FROM, если условия нет, и после WHERE — если оно есть.
SELECT gender,
       AVG(age)
FROM buyer
GROUP BY gender; 

Для оператора GROUP BY можно и не указывать агрегирующую функцию: тогда на экране отобразится только список уникальных значений, которые содержатся в поле.
В группировках можно указывать псевдонимы

//Стиль запроса
SELECT sp.advertising_id,
       sp.install_date,
       sp.session_num,
       sp.payer,
       sp.last_active AS last_date,
       DATE_DIFF(sp.last_active, install_date, DAY) AS max_play
FROM players AS sp
WHERE sp.date = '2021-02-28'
  AND sp.install_date BETWEEN '2021-02-01' AND '2021-02-26'; 
Оформить запрос по всем правилам можно вручную или с помощью SQL-форматера, например SQLFormat//

